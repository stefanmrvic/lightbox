*,
*::before,
*::after {
    box-sizing: border-box;
}

/** 
This is dangerous. Sometimes you want elements to have margins & paddings such as <ul> elements. Always best 
to be specific with your selectors.
*/
/*  * {
    margin: 0;
    padding: 0;
  }
*/

body {
    margin: 0;
    padding: 0;
}

/*
  You had media queries, in reality there's not even a need for them you can let everything scale automatically.
  By wrapping each image by a div, we can have set dimensions for each container and have the image be always
  centered and cropped if necessary. This way we can actually create a grid that looks evenly distributed. When
  the user wants to see the full picture, they can click on it and a lightbox will appear. It's why you have the whole
  lightbox functionality in the first place.
*/
.grid {
    display: flex;
    flex-wrap: wrap;
    gap: 16px; /* We use the `gap` property on a flex container to determine what the spacing between items needs to be. */
    justify-content: center;
    max-width: 932px; /* Each grid item should be 300px wide, so 3 x 300px = 900px. However, there's also 2 x 16px worth of spacing on each row. So 932px means exactly three items can live next to each other. */
    margin: 0 auto; /* Center the grid */
}

.grid-item {
    /*
    There's rarely a case where you'd want to set the `width` property to an exact px amount. You can make it
    automatically scalable by using percentages. This way, the grid will always be responsive, and if the viewport
    becomes to narrow, the grid items will automatically wrap to the next row, or the grid items will scale down due
    to the % definition instead of a hard-coded px value.
     */
    max-width: 300px;
    width: 100%;
    height: 300px;
    overflow: hidden;
    /*
    We position the parent element "relative" so that the img inside can be positioned "absolute" and centered
    inside the parent element. This way, the image will always be centered and cropped if necessary and you get equal
    size grid items.
    */
    position: relative;
    transition: transform 0.15s ease-in-out;

    /* 
    Recently we've been allowed to directly nest using native CSS. Support is a little over 90%: https://caniuse.com/css-nesting
    so in an actual project I would still use a CSS preprocessor like SCSS or LESS.
    https://sass-lang.com/ 
    */
    &:hover {
        cursor: pointer;
        transform: scale(1.05);
    }

    img {
        position: absolute;
        /*
      These following three lines of code will center the image inside the parent element. The image will always be
      centered and cropped if necessary. This way, you can have equal size grid items.
      */
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);

        /* 
      We can now set the width and height to 100% and use the object-fit property to make sure the image is always
      properly scaled in its own aspect ratio. Try removing the object fit and see what happens. There's also "contain"
      which means it would never crop the image, but it would always fit the image inside the container. 
      */
        width: 100%;
        height: 100%;
        object-fit: cover;
    }
}

#lightbox {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    animation: fadeIn 0.3s forwards;
    opacity: 0;

    &.fade-out {
        animation: fadeOut 0.3s;
    }

    button {
        background: none;
        border: none;
    }
}

.lightbox__container {
    height: 100%;
    width: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    background: rgba(0, 0, 0, 0.8);
}

.lightbox__image {
    display: flex;
    justify-content: center;
    align-items: center;

    img {
      max-width: 500px;
      height: auto;
    }
}

.lightbox__close {
    cursor: pointer;
    font-size: 40px;
    color: white;
    position: absolute;
    top: 7%;
    right: 9%;
}

.lightbox__navigation {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  display: flex;
  padding: 0 16px;
  justify-content: space-between;
  width: 100%;
  pointer-events: none;

  button {
    pointer-events: all;
    color: #FFF;
    font-size: 40px;
  }
}

@keyframes fadeIn {
    from {
        opacity: 0;
    }
    to {
        opacity: 1;
    }
}

@keyframes fadeOut {
    from {
        opacity: 1;
    }
    to {
        opacity: 0;
    }
}
